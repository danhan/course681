package bixi.hbase.upload;

import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.IOException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.hadoop.hbase.client.Put;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import util.quadtree.based.trie.XQuadTree;

import bixi.dataset.collection.XStation;
import bixi.hbase.query.BixiConstant;

/**
 * Schema1: key(quadTree index which is generated by trie-based tree),
 * columns(s1,s2..), values(static information of stations)
 * 
 * @author dan
 * 
 */
public class TableInsertLocationS1 extends TableInsertAbstraction {

	String tableName = BixiConstant.LOCATION_TABLE_NAME_1;
	String familyName = BixiConstant.LOCATION_FAMILY_NAME;
	XQuadTree quadTree = null;

	public TableInsertLocationS1() throws IOException {		
		super();
		hbase.getTableHandler(tableName);
		// This should be known before indexing with QuadTree.
		Rectangle2D.Float space = new Rectangle2D.Float(
				(float) BixiConstant.MONTREAL_TOP_LEFT_X,
				(float) BixiConstant.MONTREAL_TOP_LEFT_Y,
				(float) BixiConstant.MONTREAL_AREA_WIDTH,
				(float) BixiConstant.MONTREAL_AREA_HEIGHT);
		// The min size of subspace, this is based on the queries
		float min_size_of_subspace = (float) BixiConstant.MIN_SIZE_OF_SUBSPACE;
		// build up a quadtree.
		quadTree = new XQuadTree(space, min_size_of_subspace);
		quadTree.buildTree();
	}

	@Override
	public void insert() {
		int batchNum = 100;
		File dir = new File("data2/sub");
		String fileName = dir.getAbsolutePath() + "/01_10_2010__00_00_01.xml";
		insert(fileName, batchNum);
	}

	public static void main(String[] args) throws ParserConfigurationException,
			IOException {
		TableInsertLocationS1 inserter = new TableInsertLocationS1();
		inserter.insert();
	}

	/**
	 * Read the location from file, parse it, index it, and then insert it
	 * TODO Normalize the point: enlarge the width and height, so all the points are in the scope now.
	 * @param filename
	 *            original file including all location information
	 * @param batchNum
	 *            how many rows can be written at one go
	 */
	public void insert(String filename, int batchNum) {
		try {
			File f = new File(filename);
			Document dom = null;
			try {
				DocumentBuilderFactory dbf = DocumentBuilderFactory
						.newInstance();
				DocumentBuilder db = dbf.newDocumentBuilder();
				dom = db.parse(f);
			} catch (SAXException e) {
				e.printStackTrace();
				System.err.println("File is malformed:" + filename);
			} catch (IOException e) {
				e.printStackTrace();
				System.err.println("File is malformed:" + filename);
			}
			if (dom != null) {
				Element elem = dom.getDocumentElement();
				NodeList nodes = elem.getElementsByTagName("station");
				Element e;
				for (int i = 0; i < nodes.getLength(); i++) {
					try {
						e = (Element) nodes.item(i);
						// get the location
						XStation station = reader.getStation(e);
						// index the location
						XQuadTree node = quadTree.locate(
								(float) station.getLatitude(),
								(float) Math.abs(station.getlongitude()));
						//System.out.println(quadTree.getM_rect().toString());
						//System.out.println((float) station.getLatitude()+" ; "+(float) Math.abs(station.getlongitude()));
						String key = node.getIndex();
						// insert it into hbase
						Put put = new Put(key.getBytes());
						put.add(familyName.getBytes(), station.getId()
								.getBytes(), station.getMetadata().getBytes());
						this.hbase.getHTable().put(put);

					} catch (Exception e1) {
						e1.printStackTrace();
						System.err.println("Malformed Station ID data");
						throw new IOException();
					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			this.hbase.closeTableHandler();
		}

	}

}
